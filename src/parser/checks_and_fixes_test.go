package parser

import (
	"os"
	"runtime"
	"testing"
)

// Test the CheckAction() function
func TestCheckAction(t *testing.T) {

	value_name := SYMBOL_ACTION

	result := CheckAction("1", value_name)

	if result != nil {
		t.Errorf(
			"CheckAction did not return true, invalid action symbol passed",
		)
	}
}

// Test the CheckIsStatement() function
func TestCheckIsStatement(t *testing.T) {
	/* Generate a valid statement name for testing. Here, we're providing one
	rather than pulling one from values.STATEMENT_NAMES which would be
	logical but that slice is generated by the parser at runtime so we
	need to "prepopulate" it here so to speak.
	*/
	STATEMENT_NAMES = append(
		STATEMENT_NAMES,
		"writeln",
	)
	valid_statement := "writeln"
	// Set a random statement name that is invalid
	invalid_statement := "RANDOM!"

	// Get a response to the CheckIsStatement that should return true
	valid_result := CheckIsStatement(valid_statement)
	// Get a response to the CheckIsStatement that should return false
	invalid_result := CheckIsStatement(invalid_statement)

	// If a valid statement name returns false...
	if !valid_result {
		t.Errorf(
			"CheckIsStatement returned false when it should have returned " +
				"true",
		)
	}
	// If an invalid statement name returns true...
	if invalid_result {
		t.Errorf(
			"CheckIsStatement returned true when it should have returned " +
				"false",
		)
	}
}

// Test the CheckVariablePrefix() function
func TestCheckVariablePrefix(t *testing.T) {

	prefix := "x_"
	value_name := "Hello"

	result := CheckVariablePrefix("1", prefix, value_name)

	if result != nil {
		t.Errorf(
			"CheckVariablePrefix did not return true, passed %q",
			value_name,
		)
	}
}

// Test the CheckValidAssignment() function
func TestCheckValidAssignment(t *testing.T) {

	result := CheckValidAssignment("1", SYMBOL_OPERATOR_ASSIGNMENT)

	if result != nil {
		t.Errorf(
			"CheckValidAssignment did not return true, invalid assignment " +
				"operator passed",
		)
	}
}

func TestCheckValidNumberOfTokens(t *testing.T) {
	sample_simple_tokens := []Token{
		{
			FullLineOfCode:       "writeln \"Hello World!\"",
			LineNumber:           1,
			TokenPosition:        "0",
			TokenValue:           "",
			TokenType:            "string",
			NonCommentLineNumber: 1,
		},
		{
			FullLineOfCode:       "writeln \"Hello World!\"",
			LineNumber:           1,
			TokenPosition:        "1",
			TokenValue:           "writeln",
			TokenType:            "string",
			NonCommentLineNumber: 1,
		},
		{
			FullLineOfCode:       "writeln \"Hello World!\"",
			LineNumber:           1,
			TokenPosition:        "9",
			TokenValue:           "\"Hello World!\"",
			TokenType:            "string",
			NonCommentLineNumber: 1,
		},
	}
	valid_num, _ := CheckValidNumberOfTokens(sample_simple_tokens, 2)

	if valid_num != true {
		t.Errorf(
			"CheckValidNumberOfTokens did not return true, invalid number " +
				"of tokens",
		)
	}
}

func TestCheckFileExists(t *testing.T) {
	file_not_exists := CheckFileExists("fake_file.fake")
	_, current_file, _, _ := runtime.Caller(0)
	file_exists := CheckFileExists(current_file)

	if file_not_exists != false {
		t.Errorf(
			"CheckFileExists did not return false on an invalid file name",
		)
	}

	if file_exists != true {
		t.Errorf(
			"CheckFileExists did not return true on an valid file name",
		)
	}
}

/*
This is a simple test to ensure that the CheckValidMinverLocationCount()
function is working. This checks a few circumstances - that the minver
statement is in the right place and that there is only one of them.
*/
func TestCheckValidMinverLocationCount(t *testing.T) {
	// A valid sample
	valid_sample := []string{
		"minver 1",
		"writeln \"Hello world!\"",
		"ask \"Name: \" to name",
		"writeln \"Hello #name!\"",
	}

	// minver not on the first line
	invalid_sample_one := []string{
		"writeln \"Hello world!\"",
		"minver 1",
		"ask \"Name: \" to name",
		"writeln \"Hello #name!\"",
	}

	// minver provided twice
	invalid_sample_two := []string{
		"minver 1",
		"minver 1",
		"writeln \"Hello world!\"",
		"ask \"Name: \" to name",
		"writeln \"Hello #name!\"",
	}

	valid, _ := CheckValidMinverLocationAndCount(valid_sample)
	invalid_one, _ := CheckValidMinverLocationAndCount(invalid_sample_one)
	invalid_two, _ := CheckValidMinverLocationAndCount(invalid_sample_two)

	/*
		Error out if the valid minver statement location and count returns
		false which indicates that something is wrong with the check of a valid
		use of the minver statement.
	*/
	if !valid {
		t.Errorf(
			"[CheckValidMinverLocationCount] Valid sample returned false, " +
				"expected true",
		)
	}

	// Error out of the minver statement is not at the top
	if invalid_one {
		t.Errorf(
			"[CheckValidMinverLocationCount] Invalid location returned " +
				"true, expected false",
		)
	}

	// Error out if there is more than one minver statement
	if invalid_two {
		t.Errorf(
			"[CheckValidMinverLocationCount] Invalid count returned " +
				"true, expected false",
		)
	}
}

/*
This is a simple test to make sure that CheckShebang returns the appropriate
values for the shebang character check and the path check.
*/
func TestCheckShebang(t *testing.T) {
	/*
		Get the current executable so as to simulate the name of an exectuable
		that we can guarantee exists.
	*/
	valid_binary, _ := os.Executable()
	/*
		Insert some random characters at the end of the current executable to
		make an invalid one
	*/
	invalid_binary := valid_binary + "-ub3iwulbveliuvbperivbeiuvb"
	// Setup four test shebang lines
	// An valid shebang line and binary
	valid_shebang_valid_path := "#!" + valid_binary
	// An valid shebang line and invalid binary
	valid_shebang_invalid_path := "#!" + invalid_binary
	// An valid shebang line and binary
	invalid_shebang_valid_path := "--" + valid_binary
	// An valid shebang line and invalid binary
	invalid_shebang_invalid_path := "--" + invalid_binary

	valid_shebang, valid_path := CheckShebang(
		valid_shebang_valid_path)
	valid_shebang_two, invalid_path := CheckShebang(
		valid_shebang_invalid_path)
	invalid_shebang, valid_path_two := CheckShebang(
		invalid_shebang_valid_path)
	invalid_shebang, invalid_path_two := CheckShebang(
		invalid_shebang_invalid_path)

	if valid_shebang != true && valid_path != true {
		t.Errorf(
			"[CheckShebang] Check shebang returned %t, %t"+
				", expected true, true",
			valid_shebang,
			valid_path,
		)
	}

	if valid_shebang_two != true && invalid_path != false {
		t.Errorf(
			"[CheckShebang] Check shebang returned %t, %t"+
				", expected true, false",
			valid_shebang_two,
			invalid_path,
		)
	}

	if invalid_shebang != false && valid_path_two != true {
		t.Errorf(
			"[CheckShebang] Check shebang returned %t, %t"+
				", expected false, true",
			invalid_shebang,
			valid_path_two,
		)
	}

	if invalid_shebang != false && invalid_path_two != false {
		t.Errorf(
			"[CheckShebang] Check shebang returned %t, %t"+
				", expected false, false",
			invalid_shebang,
			invalid_path_two,
		)
	}

}

// A simple test of the FixStringQuotations() function
func TestFixStringQuotations(t *testing.T) {
	test_string := "\"Hello World\""
	test_pass := "Hello World"

	result := FixStringQuotations(test_string)

	if result != test_pass {
		t.Errorf(
			"FixStringQuotations returned %q, got %q",
			test_pass,
			result,
		)
	}

	test_string_complex := "\"Hello\" World\"\""
	test_pass_complex := "Hello\" World\""

	result_complex := FixStringQuotations(test_string_complex)

	if result_complex != test_pass_complex {
		t.Errorf(
			"FixStringQuotations returned %q, got %q",
			test_pass_complex,
			result_complex,
		)
	}
}

func TestFixStringEscapes(t *testing.T) {
	results := FixStringEscapes("\"Hello World\"")
	pass := "\"Hello World\""
	if results != pass {
		t.Errorf(
			"FixStringEscapes returned %q, got %q",
			pass,
			results,
		)
	}

	results_newline := FixStringEscapes("\"Hello\\n World\"")
	pass_newline := "\"Hello\n World\""
	if results_newline != pass_newline {
		t.Errorf(
			"FixStringEscapes returned %q, got %q",
			pass,
			results,
		)
	}

	results_charrret := FixStringEscapes("\"Hello\\r World\"")
	pass_charrret := "\"Hello\r World\""
	if results_charrret != pass_charrret {
		t.Errorf(
			"FixStringEscapes returned %q, got %q",
			pass,
			results,
		)
	}
}

func TestFixPathSeperators(t *testing.T) {
	results := FixPathSeperators("/home/user")
	pass := "/home/user" + string(os.PathSeparator)

	if results != pass {
		t.Errorf(
			"FixPathSeperators returned %q, got %q",
			pass,
			results,
		)
	}
}
