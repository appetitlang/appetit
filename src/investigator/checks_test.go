package investigator

import (
	"appetit/values"
	"runtime"
	"testing"
)

// Test the CheckAction() function
func TestCheckAction(t *testing.T) {

	value_name := values.SYMBOL_ACTION

	result := CheckAction("1", value_name)

	if result != nil {
		t.Errorf(
			"CheckAction did not return true, invalid action symbol passed",
		)
	}
}

// Test the CheckIsStatement() function
func TestCheckIsStatement(t *testing.T) {
	/* Generate a valid statement name for testing. Here, we're providing one
		rather than pulling one from values.STATEMENT_NAMES which would be
		logical but that slice is generated by the parser at runtime so we
		need to "prepopulate" it here so to speak.
	*/
	values.STATEMENT_NAMES = append(
		values.STATEMENT_NAMES,
		"writeln",
	)
	valid_statement := "writeln"
	// Set a random statement name that is invalid
	invalid_statement := "RANDOM!"

	// Get a response to the CheckIsStatement that should return true
	valid_result := CheckIsStatement("1", valid_statement)
	// Get a response to the CheckIsStatement that should return false
	invalid_result := CheckIsStatement("1", invalid_statement)

	// If a valid statement name returns false...
	if !valid_result {
		t.Errorf(
			"CheckIsStatement returned false when it should have returned " +
			"true",
		)
	}
	// If an invalid statement name returns true...
	if invalid_result {
		t.Errorf(
			"CheckIsStatement returned true when it should have returned " +
			"false",
		)
	}
}

// Test the CheckVariablePrefix() function
func TestCheckVariablePrefix(t *testing.T) {

	prefix := "x_"
	value_name := "Hello"

	result := CheckVariablePrefix("1", prefix, value_name)

	if result != nil{
		t.Errorf(
			"CheckVariablePrefix did not return true, passed %q",
			value_name,
		)
	}
}

// Test the CheckValidAssignment() function
func TestCheckValidAssignment(t *testing.T) {

	result := CheckValidAssignment("1", values.OPERATOR_ASSIGNMENT)

	if result != nil {
		t.Errorf(
			"CheckValidAssignment did not return true, invalid assignment " +
			"operator passed",
		)
	}	
}

func TestCheckValidNumberOfTokens(t *testing.T) {
	sample_simple_tokens := []values.Token{
		{
				FullLineOfCode: "writeln \"Hello World!\"",
				LineNumber: 1,
				TokenPosition: "0",
				TokenValue: "",
				TokenType: "string",
				NonCommentLineNumber: 1,
		},
		{
				FullLineOfCode: "writeln \"Hello World!\"",
				LineNumber: 1,
				TokenPosition: "1",
				TokenValue: "writeln",
				TokenType: "string",
				NonCommentLineNumber: 1,
		},
		{
				FullLineOfCode: "writeln \"Hello World!\"",
				LineNumber: 1,
				TokenPosition: "9",
				TokenValue: "\"Hello World!\"",
				TokenType: "string",
				NonCommentLineNumber: 1,
		},
	}
	valid_num, _ := ValidNumberOfTokens(sample_simple_tokens, 2)

	if valid_num != true {
		t.Errorf(
			"CheckValidNumberOfTokens did not return true, invalid number " +
			"of tokens",
		)
	}
}

func TestCheckFileExists(t *testing.T) {
	file_not_exists := FileExists("fake_file.fake")
	_, current_file, _, _ := runtime.Caller(0)
	file_exists := FileExists(current_file)

	if file_not_exists != false {
		t.Errorf(
			"CheckFileExists did not return false on an invalid file name",
		)
	}

	if file_exists != true {
		t.Errorf(
			"CheckFileExists did not return true on an valid file name",
		)
	}
}